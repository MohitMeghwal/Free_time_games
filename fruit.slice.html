<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Fruit Slice</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      overflow: hidden;
      touch-action: none;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      background: #222;
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }
    .overlay {
      position: fixed; /* Changed to fixed for true fullscreen */
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2;
    }
    button {
      background: #0ff;
      border: none;
      padding: 10px 20px;
      font-size: 18px;
      margin-top: 20px;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="startScreen" class="overlay">
    <h1>Fruit Slice</h1>
    <button id="startButton" onclick="startGame()">Start</button>
  </div>
  <div id="gameOverScreen" class="overlay" style="display:none;">
    <h2>Game Over</h2>
    <p id="scoreText"></p>
    <p id="highScoreText"></p>
    <button id="restartButton" onclick="restartGame()">Restart</button>
  </div>

  <audio id="bgMusic" src="https://cdn.pixabay.com/download/audio/2022/03/14/audio_7b9d5f5f8e.mp3" loop></audio>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const bgMusic = document.getElementById("bgMusic");

      let objects = [];
      let particles = [];
      let score = 0;
      let highScore = 0;
      let gameRunning = false;
      let baseSpeed = 2.5;
      let baseSpawnRate = 90;
      let currentSpeed = baseSpeed;
      let currentSpawnRate = baseSpawnRate;
      let frame = 0;
      let slicePoints = [];

      const fruitEmojis = ['🍈', '🍊', '🍇', '🍋', '🍍', '🥭', '🍎', '🍏', '🍐', '🍑', '🍓'];

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function initGame() {
        objects = [];
        particles = [];
        slicePoints = [];
        score = 0;
        currentSpeed = baseSpeed; // Reset to initial speed (2.5) on start/restart
        currentSpawnRate = baseSpawnRate; // Reset to initial spawn rate
        frame = 0;
        gameRunning = true;
      }

      function drawObject(obj) {
        ctx.font = `${obj.r * 2}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(obj.emoji, obj.x, obj.y);
      }

      function drawParticles() {
        for (let p of particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1;
          p.alpha -= 0.02;
          ctx.fillStyle = `rgba(0, 255, 0, ${p.alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }
        particles = particles.filter(p => p.alpha > 0);
      }

      function drawSliceTrail() {
        if (slicePoints.length < 2) return;
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(slicePoints[0].x, slicePoints[0].y);
        for (let i = 1; i < slicePoints.length; i++) {
          ctx.lineTo(slicePoints[i].x, slicePoints[i].y);
        }
        ctx.stroke();
        slicePoints = slicePoints.slice(-10);
      }

      function drawScore() {
        ctx.fillStyle = "#fff";
        ctx.font = "18px sans-serif";
        ctx.fillText("Score: " + score, 10, 30);
      }

      function checkCollision(x, y) {
        let collisionDetected = false;
        let objectsToCheck = [...objects];
        for (let obj of objectsToCheck) {
          let dx = x - obj.x;
          let dy = y - obj.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < obj.r * 1.5) {
            if (obj.type === "bomb") {
              endGame();
              return true;
            } else {
              score += 1; // 1 point per fruit sliced
              createParticles(obj.x, obj.y);
              objects = objects.filter(o => o !== obj);
              collisionDetected = true;
              // Update speed and spawn rate based on score
              if (score % 10 === 0) {
                currentSpeed += 0.2; // Increase speed by 0.2 every 10 fruits
                if (currentSpawnRate > 30) currentSpawnRate -= 10; // Decrease spawn interval faster
              }
            }
          }
        }
        return collisionDetected;
      }

      function createParticles(x, y) {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x,
            y,
            r: 3 + Math.random() * 3,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            alpha: 1
          });
        }
      }

      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let obj of objects) {
          obj.y -= currentSpeed;
          drawObject(obj);
        }
        drawParticles();
        drawSliceTrail();
        drawScore();

        let oldObjects = [...objects];
        objects = oldObjects.filter(obj => obj.y + obj.r > 0);
        let removed = oldObjects.filter(obj => obj.y + obj.r <= 0);
        for (let rem of removed) {
          if (rem.type === "fruit") {
            endGame();
            break;
          }
        }

        if (frame % currentSpawnRate === 0) {
          const r = 20 + Math.random() * 20;
          const x = Math.random() * (canvas.width - r * 2) + r;
          const type = Math.random() < 0.2 ? "bomb" : "fruit";
          const emoji = type === "bomb" ? "💣" : fruitEmojis[Math.floor(Math.random() * fruitEmojis.length)];
          objects.push({ x, y: canvas.height + r, r, type, emoji });
        }

        frame++;
        if (gameRunning) requestAnimationFrame(update);
      }

      function startGame() {
        try {
          document.getElementById("startScreen").style.display = "none";
          bgMusic.play().catch(err => {
            console.log("Audio playback failed:", err);
          });
          initGame();
          update();
        } catch (err) {
          console.error("Error starting game:", err);
        }
      }

      function restartGame() {
        try {
          document.getElementById("gameOverScreen").style.display = "none";
          bgMusic.play().catch(err => {
            console.log("Audio playback failed:", err);
          });
          initGame();
          update();
        } catch (err) {
          console.error("Error restarting game:", err);
        }
      }

      function endGame() {
        gameRunning = false;
        bgMusic.pause();
        if (score > highScore) highScore = score;
        document.getElementById("scoreText").textContent = "Score: " + score;
        document.getElementById("highScoreText").textContent = "High Score: " + highScore;
        document.getElementById("gameOverScreen").style.display = "flex";
      }

      let isDragging = false;
      canvas.addEventListener("mousedown", e => {
        if (!gameRunning) return;
        isDragging = true;
        slicePoints.push({ x: e.clientX, y: e.clientY });
        checkCollision(e.clientX, e.clientY);
      });

      canvas.addEventListener("mousemove", e => {
        if (!gameRunning || !isDragging) return;
        slicePoints.push({ x: e.clientX, y: e.clientY });
        checkCollision(e.clientX, e.clientY);
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
        slicePoints = [];
      });

      canvas.addEventListener("touchstart", e => {
        if (!gameRunning) return;
        e.preventDefault();
        const touch = e.touches[0];
        slicePoints.push({ x: touch.clientX, y: touch.clientY });
        checkCollision(touch.clientX, touch.clientY);
      });

      canvas.addEventListener("touchmove", e => {
        if (!gameRunning) return;
        e.preventDefault();
        const touch = e.touches[0];
        slicePoints.push({ x: touch.clientX, y: touch.clientY });
        checkCollision(touch.clientX, touch.clientY);
      });

      canvas.addEventListener("touchend", () => {
        slicePoints = [];
      });

      const startButton = document.getElementById("startButton");
      if (startButton) {
        startButton.addEventListener("click", startGame);
      } else {
        console.error("Start button not found!");
      }

      const restartButton = document.getElementById("restartButton");
      if (restartButton) {
        restartButton.addEventListener("click", restartGame);
      } else {
        console.error("Restart button not found!");
      }
    });
  </script>
</body>
</html>
